# Solid Principles

ðŸ”´The Solid Principles are a set of coding principles that provide a guide to writing maintainable, scalable, and robust software.
These principles are often considered as best practices in object-oriented programming and software design, and are used to develop maintainable, scalable, and reusable software. 

ðŸ”´The Solid principles are not limited to classes, it can be applied to various software entities such as modules, functions, and components.

ðŸ”´Solid is primarily designed for object-oriented programming, but its principles can be applied to other programming paradigms as well.
The Solid principles provide general guidelines for writing maintainable and scalable code, and they are not limited to a particular programming language or paradigm.

![alt text](https://github.com/alidehkhodaei/solid-principles/raw/main/photos/solid.png)


## âœ…Single Responsibility Principle (Srp):
A class should have only one reason to change, meaning it should have only one responsibility.

![alt text](https://github.com/alidehkhodaei/solid-principles/raw/main/photos/srp.png)


## âœ…Open/Closed Principle (Ocp):
Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.

![alt text](https://github.com/alidehkhodaei/solid-principles/raw/main/photos/ocp.png)


## âœ…Liskovâ€™s Substitution Principle (Lsp):
Subtypes must be replaceable with their base types without affecting the correctness of the program.

![alt text](https://github.com/alidehkhodaei/solid-principles/raw/main/photos/lsp.png)

## âœ…Interface Segregation Principle (Isp):
Clients should not be forced to depend on interfaces they do not use.

![alt text](https://github.com/alidehkhodaei/solid-principles/raw/main/photos/isp.png)

## âœ…Dependency Inversion Principle (Dip):
High-level modules should not depend on low-level modules, both should depend on abstractions.

![alt text](https://github.com/alidehkhodaei/solid-principles/raw/main/photos/dip.png)
 
